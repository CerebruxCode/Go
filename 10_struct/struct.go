package main

import "fmt"

// STRUCTS

/*
Πέρα απο τους προκαθορισμένους, εσωτερικούς τύπους δεδομένων που διαθέστει η Go,
μπορούμε να φτιάξουμε και δικούς μας τύπους με τις δομές.

Μια δομή "struct" είναι μια συλλογή πεδίων. Η λέξη-κλειδί type ξεκινάει ένα νέο τύπο.
Ακολουθείται από το όνομα του τύπου (Circle), τη λέξη-κλειδί struct για να δείξει
ότι έχουμε ορίσει ένα τύπο δομής και μια λίστα με τα πεδία στο εσωτερικό των αγκύλων
που περιγράφει τις ιδιότητες της δομής μας.
Κάθε πεδίο έχει ένα όνομα και έναν τύπο. Όπως και με τις συναρτήσεις έτσι και εδώ
μπορούμε να συμπτύξουμε πεδία που έχουν τον ίδιο τύπο

*/

/*
 ΣΗΜΕΊΩΣΗ: Όταν φτιάχνουμε μια struct, ο έλεγχος (go-lint) του κώδικα που κάνει ο GO compiler,
 πιθανόν να μας παραπονεθεί με το παρακάτω μήνυμα:

 comment on exported type Rectangle should be of the form \"Rectangle ...\" (with optional leading article)

	Επειδή ο τύπος που φτιάχνουμε ξεκινάει με κεφαλαία (exported), Το μόνο που χρειάζεται
	είναι να αφήσετε ένα σχόλιο πάνω απο την struct σας το οποίο να ξεκινάει
	με το όνομα της Struct, ένα κενό, στην συνέχεια μια ":", ένα κενό και
	τέλος το σχόλιο που περιγράφει τι κάνει η struct σας.
	Π.χ. Rectangle : Περιγράφω ένα ορθογώνιο
*/

// Rectangle : μπορούμε να ορίσουμε τους δικούς μας τύπους χρησιμοποιώντας
// μια δομή π.χ. εδώ περιγράφω ένα ορθογώνιο
type Rectangle struct {
	leftX  float64
	TopY   float64
	height float64
	width  float64
	// εναλακτικά μπορούμε να τα γράψουμε ε μια γραμμή "leftX, TopY, height, width float64"
}

// VertexΒ : αποτελείται απο δυο τύπους int Χ,Υ
type VertexΒ struct {
	X, Y int
}

// Vertex : αποτελείται απο δυο τύπους int Χ,Υ
type Vertex struct {
	X int
	Y int
}

// Μπορούμε να καθορίσουμε μεθόδους για το ορθογώνιο μας προσθέτοντας τον δέκτη (receiver)
// rect *Rectangle μεταξύ της func και το όνομα της συνάρτησης ώστε να μπορούμε να το καλέσουμε
// με τον τελεστή "." Γενικά τα πεδία της Struct είναι προσπελάσιμα χρησιμοποιώντας μια τελεία.

func (rect *Rectangle) area() float64 {

	return rect.width * rect.height

}

func main() {

	// Ορίζουμε ένα ορθογώνιο
	rect1 := Rectangle{leftX: 0, TopY: 50, height: 10, width: 10}

	// αν γνωρίζουμε τη σειρά μπορούμε να παραλείψουμε τα ονόματα των χαρακτηριστικών
	// π.χ.
	// rect1 := Rectangle{0, 50, 10, 10}

	// Έχουμε πρόσβαση σε τιμές των πεδίων με την . (τελεία)
	/*
		Για να αποκτήσουμε πρόσβαση στο πεδίο Χ ενός struct όταν έχουμε τον δείκτη struct p
		μπορούμε να γράψουμε (*p).X
		Ωστόσο, ο τρόποσ αυτός είναι δύσχρειστος, οπότε η γλώσσα μας επιτρέπει αντ 'αυτού
		να γράψουμε μόνο p.X, χωρίς τη ρητή δήλωση.

	*/
	fmt.Println("Rectangle is", rect1.width, "wide")

	// Καλoύμε την μέθοδο "area" για το ορθογώνιο που φτιάξαμε
	fmt.Println("Area of the rectangle =", rect1.area())

	accessVertex()
	/*
		Παρακάτω βλέπουμε την δηημιουργία μεταβλητών με Struct Literal.
		Οι γλώσσες προγραμματισμού χρησιμοποιούν τη λέξη "Literal"
		όταν γίνεται αναφορά σε συντακτικούς τρόπους για την κατασκευή
		κάποιας δομής δεδομένων. Αυτό σημαίνει ότι δεν έχει κατασκευαστεί
		ένα κενό struct στο οποίο αργότερα προσθέτουμε ή αφαιρούμε πεδία.

		Μια struct literal υποδηλώνει μια νέα εκχώρηση τιμής σε struct,
		καταγράφοντας τις τιμές των πεδίων της.


	*/

	var (
		v1 = Vertex{1, 2} // είναι type Vertex
		// Μπορείτε να καταχωρίσετε ένα υποσύνολο πεδίων χρησιμοποιώντας τη σύνταξη "Name:"
		// (Η σειρά των ονομάτων είναι άσχετη.)
		v2 = Vertex{X: 1}  // Το Y:0 υπονοείται
		v3 = Vertex{}      //  X:0 και Y:0
		v4 = Vertex{Y: 10} // X:0 και Y:10
		// Το πρόθεμα & επιστρέφει ένα δείκτη στην τιμή struct.
		p = &Vertex{1, 2} //είναι type *Vertex

	)
	fmt.Println("v1=", v1, "\nv2=", v2, "\nv3=", v3, "\nv4=", v4, "\np=", p)

}

/*
Τα πεδία Struct μπορούν να προσπελαστούν μέσω ενός struct pointer.

Για να αποκτήσουμε πρόσβαση στο πεδίο Χ ενός struct όταν έχουμε τον δείκτη struct p
μπορούμε να γράψουμε (*p).X
Ωστόσο, ο τρόποσ αυτός είναι δύσχρειστος, οπότε η γλώσσα μας επιτρέπει αντ 'αυτού
να γράψουμε μόνο p.X, χωρίς τη ρητή δήλωση.
*/
func accessVertex() {
	v := Vertex{1, 2}
	p := &v
	p.X = 1e9 // αντι (*p).X το γράφουμε p.X
	fmt.Println(v)
}
