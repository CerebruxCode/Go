/*
Τι θα μάθουμε:
- Περισσότερα σχετικά με την var: variable, μεταβλητή.
Μια μεταβλητή είναι ένα στοιχείο με όνομα της αρεσκείας
μας που αποθηκεύει μια τιμή (αριθμοί - γράμματα)
- Θα δούμε τις "μη μεταβλητές" const (constant) σταθερά.
- Θα μάθουμε την διαφορά των variables με τις package level variables
- Θα υπολογίζουμε το μήκος ενός string με τη function len(string)
- Θα δούμε τις string: είναι ο τύπος που αφορά λέξεις - σύμβολα
- Θα δούμε τις escape symbols που ειναι ειδικά σύμβολα που
  προσθέτουν η αγνοούν κάποια κατάσταση
- Θα δούμε τις bool (boolean) δηλαδή λογικοί τελεστές που
εξετάζουν αν μια συνθήκη είναι αληθής (true) η ψευδής (false)
- Θα δούμε περισσότερα για την Printf που σε αντίθεση με την Println,
η Printf χρησιμοποιείται όταν θέλουμε να τυπώνουμε το αποτέλεσμα
με συγκεκριμένο τρόπο
*/

package main

import (
	"fmt"
	/*
	   Το πακέτο fmt που χρησιμοποιούμε τοσο συχνά,
	   υλοποιεί μορφοποίηση εισόδου/εξόδου με μεθόδους
	   ανάλογους με το printf και το scanf της γλώσσας C
	*/
	"reflect" // έχει την TypeOf() function για να προσδιορίσουμε τον τύπο
	// δεδομένων που αποθηκεύει μια μεταβλητή
)

/*

Τα παρακάτω variables είναι τα λεγόμενα "package level variables". Αυτά τα variables
βρίσκονται εξω απο functions με αποτέλεσμα να μπορούν να τα χρησιμοποιήσουν όλα τα
functions που φτιάχνουμε. Αντίθετα όσα variables δημιουργούμε μέσα σε μια function
χρησιμοποιούνται μόνο μέσα σε αυτήν.

Σε package level (global) variables πάντα ξεκινάμε με την λέξη-κλειδί var.
Η Go δεν θα μας αφήσει να χρησιμοποιήσουμε μια δήλωση τύπου ":=".
Στη συνέχεια, πρέπει να ονομάσουμε τις μεταβλητές μας και να καθορίσουμε τον τύπο τους.
Στο θέμα της ονομασίας, αυτά πρέπει να ξεκινήσουν με ένα γράμμα
ή μια κάτω παύλα "_" και φυσικά, βεβαιωθείτε ότι δεν προσπαθείτε να τα
ονομάσετε με μια λέξη-κλειδί δεσμευμένη απο την Go. Άρα μην προσπαθήσετε
να ονομάσετε μια var μεταβλητή με το όνομα "var"

Τέλος σε αντίθεση με τα variables που δηλώνουμε εντός μιας function, εδω μπορούμε
να δημιουργήσουμε variable και να μην τα χρησιμοποιήσουμε άμεσα. Αν όμως τα
variables δημιουργούνται εντός της function, η Go θα μας παραπονεθεί οτι
"αν δεν την χρησιμοποιείς πουθενά, διέγραψε την"
*/
var domainName string = "Cerebrux"

// Αν θέλετε να φτιάξτε πολλά variable, μπορείτε να δηλώσετε
// πολλαπλά variable όπως παρακάτω

var (
	dedomenaA = 2 // Δηλώνουμε μια var dedeomenaA και την
	// αρχηκοποιούμε (initializing) με την τιμή 2
	// και άρα η GO καταλαβαίνει οτι είναι int
	dedomenaB = 3.1 // Δηλώνουμε μια var dedeomenaΒ και την
	// αρχηκοποιούμε (initializing) με την τιμή 3.1
	//και άρα η GO καταλαβαίνει οτι είναι float
	dedomenaC string // Δηλώνουμε μια var dedeomenaC και
	// ΔΕΝ την αρχηκοποιούμε (no initialization value).
	// Όταν δεν αρχηκοποιούμε πρέπει να δηλώσουμε τον τύπο της var.
	// Έπειτα η Go την "αρχηκοποιεί" με τιμή "empty" για χαρακτήρες (string types)
	dedomenaD int // ενώ για αριθμούς (int και float) δίνει την αρχική τιμή "0"
	dedomenaE float64
	// Επίσης variables που είναι ίδιου τύπου μπορούν γραφτούν
	// σε μια γραμμή όπως παρακάτω
	dedomenaF, dedomenaG, dedomenaH int
)

func main() {
	// Τα Strings εντός των " " μπορούν να περιλαμβάνουν escape
	// symbols όπως το \n για να τυπώσουν μια νέα γραμμή
	fmt.Printf("Μου αρέσουν οι \n\n") // το πρώτο \n είναι για να
	// πάει στην επόμενη γραμμή ενώ το δεύτερο \n για να πάει
	// στην αμέσως επόμενη. Mε αυτό τον τρόπο δημιουργούμε μια κενή γραμμή
	fmt.Println("Νέες κενές γραμμές όπως η απο πάνω μου ^^^")
	/*
		Το fmt.Pritln() χρησιμοποιείται όπως είδαμε για να εμφανίζουμε
		μηνύματα και αποτελέσματα.
		Στην Println() Τα διαστήματα προστίθενται πάντα μεταξύ των τελεστών
		ενώ στο τέλος προσαρτάται πάντα μια νέα γραμμή
		χωρίς να χρειάζεται να προσθέσετε "\n".
	*/

	// Ας δούμε τι είναι αποθηκευμένο στις variable
	// που δηλώσαμε στο package level:
	fmt.Println( // Όταν γράφουμε μια μεγάλη Println, είναι καλύτερα να την
		// γράφουμε σε μορφή λίστας προς τα κάτω.
		"dedomenaA:", dedomenaA, "και είναι τύπου:", reflect.TypeOf(dedomenaA),
		"\ndedomenaB:", dedomenaB, "και είναι τύπου:", reflect.TypeOf(dedomenaB),
		"\ndedomenaC:", dedomenaC, "και είναι τύπου:", reflect.TypeOf(dedomenaC),
		"\ndedomenaD:", dedomenaD, "και είναι τύπου:", reflect.TypeOf(dedomenaD),
		"\ndedomenaE:", dedomenaE, "και είναι τύπου:", reflect.TypeOf(dedomenaE),
		"\ndedomenaF:", dedomenaF, "και είναι τύπου:", reflect.TypeOf(dedomenaF),
		"\ndedomenaG:", dedomenaG, "και είναι τύπου:", reflect.TypeOf(dedomenaG),
		"\ndedomenaH:", dedomenaH, "και είναι τύπου:", reflect.TypeOf(dedomenaH),
		// Σε αυτή την περίπτωση πάντα η τελευταία γραμμή λήγει με κόμμα
	)
	// Το μήκος ενός string το λαμβάνουμε με τη function len(string)
	fmt.Println("Το μήκος του string Cerebrux είναι :", len(domainName))
	// Μπορείτε να ενώσετε με + (concatenate)
	fmt.Println(domainName + " : Ιστοσελίδα τεχνολογίας ")
	// Τα Booleans είναι τύποι δεδομένων αλήθειας και μπορούν
	// να πάρουν δύο τιμές, true ή false
	var isOver30 bool = true
	fmt.Println("Είναι ", isOver30)

	/*  fmt.Printf()

	Το fmt.Printf() χρησιμοποιείται επίσης για να εμφανίζουμε
	μηνύματα και αποτελέσματα αλλά σε συγκεκριμένη μορφοποίηση
	την οποία επιθυμούμε. Η μορφοποίηση δηλώνεται με %n, όπου 'n'
	όπως θα δούμε παρακάτω, είναι ένα προκαθορισμένο απο την Go γράμμα.

	Σε αντίθεση με την Println(), η Printf() δεν προσθέτει αυτόματα
	νέα γραμμή στο τέλος, οπότε αν το χρειάζεστε, μπορείτε να το δηλώσετε
	με \n.

	*/

	/*
		Τελεστές:
		%d -> δεκαδικό
		%f -> κινητής υποδιαστολής
		%s -> λέξη (συμβολοσειρά)
		%q -> λέξη εντός " "
		%v -> τιμή (οποιαδήποτε)
		%#v -> εμφανίζει την σύνταξη της Go που αναπαριστάνει την τιμή
		%T -> Τύπος της τιμής (π.χ. να εμφανίζει αν είναι int,float κλπ)
		%t -> Λογικός τελεστής (true ή false)
		%p -> δείκτης (διεύθυνση σε base 16, που ξεκινάει με 0x)
		%c -> char (rune) αντιπροσωπεύεται από το αντίστοιχο Unicode κώδικα
	*/

	// Παράδειγμα στην Printf η ένδειξη %f όπως είπαμε είναι για αριθμούς float
	// Ενώ με την %.xf (όπου x ένας ακέραιος αριθμός) μπορείτε να ορίσετε
	// και την ακρίβεια του δεκαδικού ενός float
	dekadiko := 3.26
	enasarithmos := 42
	fmt.Printf("Χωρίς στρογγυλοποίηση %f \n", dekadiko)
	fmt.Printf("Στρογγυλοποίηση %.1f \n", dekadiko) // στρογγυλοποίηση του δεύτερου δεκαδικού στο πρώτο
	// Αντί της reflect.TypeOf μπορούμε να χρησιμοποιήσουμε και την %T.
	// Η %T μας τυπώνει τον τύπο του variable για να ελέγξουμε
	// π.χ. ως τι είναι αποθηκευμένος
	fmt.Printf("Είναι τύπος : %T \n", dekadiko)
	// Η %t τυπώνει τα booleans
	fmt.Printf("Bool : %t \n", isOver30)
	// %d χρησιμοποιείται για integers
	fmt.Printf("Intiger %d \n", 100)
	// %b τυπώνει σε binary μορφή
	fmt.Printf("H binary μορφή του 100: %b \n", 100)
	// %c τυπώνει τον χαρακτήρα που σχετίζεται με το keycode
	fmt.Printf("Το keycode του 44 αντιστοιχεί σε: %c \n", 44)
	// %x τυπώνει σε hexcode
	fmt.Printf("Το hexcode του 17 είναι: %x \n", 17)
	// %e τυπώνει με επιστημονικό συμβολισμό
	fmt.Printf("Ο επιστημονικό συμβολισμός του 3.26000 : %e \n", dekadiko)
	// Θυμηθείτε γιατί βάζουμε στα παρακάτω το \n. Δοκιμάστε να το αφαιρέσετε
	fmt.Printf("το enasarithmos είναι %d, το dekadiko είναι %f, το domainName είναι %s \n", enasarithmos, dekadiko, domainName)
	fmt.Printf("Ας βάλουμε σε \"\" το Cerebrux => %q\n", domainName) // τα \"\" είναι escape caracters

	grades := []int{10, 20, 30} // φτιάχνουμε ένα slice το οποίο θα μάθουμε σε επόμενο μάθημα
	fmt.Printf("%v\n", grades)  // => [10 20 30]
	fmt.Printf("%#v\n", grades) // μας εμφανίζει το πως είναι γραμμένο => []int{10, 20, 30}

	deiktis := 15
	fmt.Printf("Η διεύθυνση του δείκτη &deiktis είναι: %p\n", &deiktis)
	
	//To fmt.Sprintf() μετατρέπει και επιστρέφει λέξεις. Χρησιμοποιεί
	// τους ίδιους τελεστές με την fmt.Printf()
	alpha, beta, ceta := 10, 15.5, "Μια λέξη"
	s := fmt.Sprintf("το a είναι %d, το b είναι %f, το c είναι %s \n", alpha, beta, ceta)
	fmt.Println(s)

	// === Constants ===

	// Ένα constant είναι ενα variable η τιμή του οποίου
	// δεν θέλουμε και δεν μπορεί να αλλάξει. Μπορούμε
	// να δηλώσουμε (typed) η και όχι (untyped) τον τύπο της constant

	const pi float64 = 3.14159265359 // typed constant
	const e = 3.14                   // untyped constant
	_, _ = pi, e                     // χρησιμοποιώντας τον τρόπο "_ = var" κάνουμε "mute"
	// την go όταν δεν θέλουμε να παραπονιέται οτι δεν χρησιμοποιούμε
	// μια μεταβλητή. Για όσες μεταβλητές θέλουμε να κάνουμε mute
	// τόσες κάτω παύλες πρέπει να χρησιμοποιήσουμε π.χ.:
	// _, _, _, _, _ = var1, var2, var3, var4, var5

	/*
		Τα const μπορούν να είναι μονο :
		- boolean constants,
		- rune constants,
		- integer, floating-point constants,
		- complex constants, και
		- string constants.
	*/

	// Μπορούμε να δημιουργήσουμε ταυτόχρονα
	// πολλαπλά (grouped) constants
	// σε παρένθεση ή σε μια σειρά
	const (
		a         = 5   // untyped constant
		b float64 = 0.1 // typed constant
	)
	_, _ = a, b // τα κάνουμε mute αφού δεν τα χρειαζόμαστε
	const n, m int = 4, 5
	_, _, _, _ = a, b, n, m // τα κάνουμε mute αφού δεν τα χρειαζόμαστε
	// Μπορούμε να αρχικοποιήσουμε την πρώτη constant και
	// οι επόμενες να κληρονομήσουν τον τύπο και την τιμή
	// απο το πρώτο
	const (
		min1 = -500
		max1 // λαμβάνει το τύπο και την τιμή απο το προηγούμενο => 500
		max2 // σε ομαδικό const, ένα επόμενο const επαναλαμβάνει το
		// προηγούμενο const=> 500
	)
	_, _, _ = min1, max1, max2 // τα κάνουμε mute αφού δεν τα χρειαζόμαστε

	// === Κανόνες των CONSTANTS ===

	// 1. Δεν μπορείς να αλλάξεις την τιμή του constant
	const temp int = 100
	_ = temp // muted
	// Αν γράψεις :
	// temp = 50 // θα λάβεις compile-time error

	// 2. Δεν μπορείτε να αρχικοποιήσετε μια const
	// κατά το χρόνο εκτέλεσης (οι const ανήκουν στο χρόνο μεταγλώττισης)
	// Δοκίμασε το παρακάτω:

	// const power = math.Pow(2, 3)

	// 3. δεν μπορούμε να χρησιμοποιήσουμε τη συντομογραφία
	// όπου δηλώνουμε και ταυτόχρονα αρχικοποιούμε με
	// τον τελεστή ":=" όπως κάνουμε με τις variables
	// και θα πρέπει πάντα να τις ξεκινάμε με την λέξη "const".
	// Δοκίμασε τα παρακάτω:

	tamam := 5
	//const nottamam = tamam // δεν μπορεί να ανατεθεί το int στο constant

	// 4. Μπορείς να χρησιμοποιήσεις μια function όπως η len()
	// για να αρχικοποιήσεις μια const αν έχει μια παράμετρο

	const l1 = len("Hello") // έχει παράμετρο "Hello"

	var str string = "Hello"
	// const l2 = len(str) // αλλά δεν μπορείς να πάρεις την str
	// και να την προσθέσεις ως τιμή στην const belongs to runtime

	_, _, _ = tamam, l1, str

	// Ας δούμε και κάποιες πράξεις με untyped constants

	const x = 5           // untyped αλλά η Go καταλαβαίνει οτι ειναι int
	const y float64 = 1.1 // typed αφου δηλώσαμε οτι ειναι float64
	fmt.Println(x * y)    // Σε αντίθεση με var εδώ η Go μας επιτρέπει
	// να κάνουμε πράξεις μεταξύ int και float και δεν χρειάζεται πρώτα
	// να κάνουμε μετατροπή. Δοκιμάστε να μετατρέψετε το "const x = 5"
	// σε x := 5
	// Θα σας εμφανίσει mismatched types int and float64

	/*
		=== IOTA ===

		To iota είναι γεννήτρια αριθμών για constants που ξεκινά από το μηδέν
		και αυξάνεται αυτόματα κατά 1.

	*/
	const (
		proto   = iota
		deutero = iota
		trito   = iota
	)
	fmt.Println(proto, deutero, trito) // θα μας εμφανίσει => 0 1 2
	// Μπορούμε να παραλείψουμε τον τύπο και την τιμή,
	// για τις επόμενες const και να τις λάβει αυτόματα
	// επαναλαμβάνοντας τον τύπο και την τιμή του
	// πρώτου conts και στην συνέχεια να λάβει αυτόματα +1 αυτόματα
	const (
		Voras   = iota // ξεκινάμε με 0
		Anatoli        // 0+1 -> 1
		Notos          // 1+1 -> 2
		Disi           // 2+1 -> 3
	)
	fmt.Println(Anatoli, Notos, Disi)
	// Initializing the constants using a step:
	const (
		miden   = iota * 2 // -> 0
		dyo                // -> 2
		tessera            // -> 4
	)
	fmt.Println(miden, dyo, tessera)
}
