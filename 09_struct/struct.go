package main

import "fmt"

// STRUCTS

/*
	Πέρα απο τους προκαθορισμένους, εσωτερικούς τύπους δεδομένων που διαθέτει η Go,
	μπορούμε να φτιάξουμε και δικούς μας τύπους με τις δομές.

	Μια δομή "struct" είναι μια συλλογή πεδίων. ε την λέξη-κλειδί "type" ξεκινάμε ένα νέο τύπο.
	Αυτό ακολουθείται από το όνομα του τύπου (π.χ. Circle), τη λέξη-κλειδί struct για να δείξει
	ότι έχουμε ορίσει ένα τύπο struct και τέλος μια λίστα με τα πεδία στο εσωτερικό των αγκύλων
	που περιγράφει τις ιδιότητες της struct μας.
	Κάθε πεδίο έχει ένα όνομα και έναν τύπο. Όπως και με τις functions έτσι και εδώ
	μπορούμε να συμπτύξουμε πεδία που έχουν τον ίδιο τύπο

*/

/*
 ΣΗΜΕΊΩΣΗ: Όταν φτιάχνουμε μια struct, ο έλεγχος (go-lint) του κώδικα που κάνει ο GO compiler,
 πιθανόν να μας παραπονεθεί με το παρακάτω μήνυμα:

 comment on exported type Rectangle should be of the form \"Rectangle ...\" (with optional leading article)

	Επειδή ο τύπος που φτιάχνουμε ξεκινάει με κεφαλαία (exported), Το μόνο που χρειάζεται
	είναι να αφήσετε ένα σχόλιο πάνω απο την struct σας το οποίο να ξεκινάει
	με το όνομα της Struct, ένα κενό, στην συνέχεια μια ":", ένα κενό και
	τέλος το σχόλιο που περιγράφει τι κάνει η struct σας.
	Π.χ. Rectangle : Περιγράφω ένα ορθογώνιο
	Αυτά τα σχόλια μπορούν να χρησιμοποιηθούν απο την εντολή "go doc" για να δημιουργήσετε μια τεκμηρίωση
*/

// Rectangle : μπορούμε να ορίσουμε τους δικούς μας τύπους χρησιμοποιώντας
// μια struct π.χ. εδώ περιγράφουμε ένα ορθογώνιο
type Rectangle struct {
	leftX  float64
	TopY   float64
	height float64
	width  float64
	// εναλλακτικά μπορούμε να τα γράψουμε σε μια γραμμή "leftX, TopY, height, width float64"
}

// VertexΒ : αποτελείται από δύο τύπους int Χ,Υ
type VertexΒ struct {
	X, Y int
}

// Vertex : αποτελείται από δύο τύπους int Χ,Υ
type Vertex struct {
	X int
	Y int
}

// Μπορούμε να καθορίσουμε μεθόδους για το ορθογώνιο μας προσθέτοντας το δέκτη (receiver)
// rect *Rectangle μεταξύ της func και του ονόματος της function ώστε να μπορούμε να τον καλέσουμε
// με τον τελεστή "." Γενικά τα πεδία της Struct είναι προσπελάσιμα χρησιμοποιώντας μια τελεία.

func (rect *Rectangle) area() float64 {

	return rect.width * rect.height

}

func main() {

	// Ορίζουμε ένα ορθογώνιο
	rect1 := Rectangle{leftX: 0, TopY: 50, height: 10, width: 10}

	// αν γνωρίζουμε τη σειρά μπορούμε να παραλείψουμε τα ονόματα των χαρακτηριστικών
	// π.χ.
	// rect1 := Rectangle{0, 50, 10, 10}

	// Έχουμε πρόσβαση σε τιμές των πεδίων με την . (τελεία)
	/*
		Για να αποκτήσουμε πρόσβαση στο πεδίο Χ ενός struct όταν έχουμε τον δείκτη struct p
		μπορούμε να γράψουμε (*p).X
		Ωστόσο, ο τρόπος αυτός είναι δύσχρηστος, οπότε η γλώσσα μας επιτρέπει αντ 'αυτού
		να γράψουμε μόνο p.X, χωρίς τη ρητή δήλωση.

	*/
	fmt.Println("Το Ορθογώνιο έχει", rect1.width, "πλάτος")

	// Καλούμε την μέθοδο "area" για το ορθογώνιο που φτιάξαμε
	fmt.Println("Το εμβαδόν του ορθογωνίου είναι =", rect1.area())

	accessVertex()
	/*
		Παρακάτω βλέπουμε την δημιουργία variable με Struct Literal.
		Οι γλώσσες προγραμματισμού χρησιμοποιούν τη λέξη "Literal"
		όταν γίνεται αναφορά σε συντακτικούς τρόπους για την κατασκευή
		κάποιας struct δεδομένων. Αυτό σημαίνει ότι δεν έχει κατασκευαστεί
		ένα κενό struct στο οποίο αργότερα προσθέτουμε ή αφαιρούμε πεδία.

		Μια struct literal υποδηλώνει μια νέα εκχώρηση τιμής σε struct,
		καταγράφοντας τις τιμές των πεδίων της.


	*/

	var (
		v1 = Vertex{1, 2} // είναι type Vertex
		// Μπορείτε να καταχωρίσετε ένα υποσύνολο πεδίων χρησιμοποιώντας τη σύνταξη "Name:"
		// (Η σειρά των ονομάτων είναι άσχετη.)
		v2 = Vertex{X: 1}  // Το Y:0 υπονοείται
		v3 = Vertex{}      //  X:0 και Y:0
		v4 = Vertex{Y: 10} // X:0 και Y:10
		// Το πρόθεμα & επιστρέφει ένα δείκτη στην τιμή struct.
		p = &Vertex{1, 2} //είναι type *Vertex

	)
	fmt.Println("v1=", v1, "\nv2=", v2, "\nv3=", v3, "\nv4=", v4, "\np=", p)

}

/*
Τα πεδία Struct μπορούν να προσπελαστούν μέσω ενός struct pointer.

Για να αποκτήσουμε πρόσβαση στο πεδίο Χ ενός struct όταν έχουμε τον δείκτη struct p
μπορούμε να γράψουμε (*p).X
Ωστόσο, ο τρόπος αυτός είναι δύσχρηστος, οπότε η γλώσσα μας επιτρέπει αντ 'αυτού
να γράψουμε μόνο p.X, χωρίς τη ρητή δήλωση.
*/
func accessVertex() {
	v := Vertex{1, 2}
	p := &v
	p.X = 1e9 // αντί (*p).X το γράφουμε p.X
	fmt.Println(v)
}
