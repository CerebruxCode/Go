package main

import "fmt"

// Δείκτες
// "Go passes arguments by value, and not by reference"
/*
	Όταν θέτουμε ένα variable ως όρισμα σε μια function, 
	στην πραγματικότητα η Go κάνει ένα αντίγραφο της τιμής
	που μεταβιβάζεται απο το όρισμα και τοποθετεί αυτήν 
	την τιμή στη στοίβα για χρήση από τη function που καλείται.
	Δεν βάζει την ίδια τη variable στη στοίβα, μόνο ένα αντίγραφο
	της τιμής του.

	Όταν δημιουργούμε τη variable η Go ανοίγει μια περιοχή στη μνήμη για αυτήν την variable. Ας υποθέσουμε
	ότι η διεύθυνση για αυτήν τη περιοχή μνήμης είναι η 0xAA και η τιμή που τοποθετούμε σε αυτήν είναι μια string type,
	Αν τώρα δώσουμε αυτή την variable ως όρισμα/παράμετρο σε μια function, η Go όπως είπαμε δημιουργεί στην πραγματικότητα ένα
	νέο αντίγραφο αυτής της variable σε μια διαφορετική διεύθυνση π.χ. 0xBB. Τυχόν αλλαγές που πραγματοποιούνται
	από τη function που καλούμε γίνονται μόνο στο αντίγραφο της variable, αυτή δηλαδή που βρίσκεται στη διεύθυνση 0xBB,
	οπότε η αρχική τιμή στο 0xAA είναι αμετάβλητη.

	"Pointers must be used to pass arguments by reference"
	Για να μπορούμε να διαχειριστούμε την τιμή στην αρχική variable θα χρησιμοποιήσουμε τους δείκτες

	Ένας δείκτης διατηρεί τη διεύθυνση μνήμης μιας τιμής. Οι δείκτες,
	αντί να αναφέρονται στην ίδια την τιμή, αναφέρονται σε μια τοποθεσία
	στη μνήμη όπου είναι αποθηκευμένη μια τιμή.

	Στη Go ένας δείκτης αναπαρίσταται χρησιμοποιώντας το χαρακτήρα *
	ακολουθούμενος από το τύπο της αποθηκευμένης τιμής. Ο * χρησιμοποιείται
	επίσης για να αναφερθούμε στις variables των δεικτών. Όταν
	αναφερόμαστε σε ένα δείκτη έχουμε πρόσβαση στην τιμή που αυτός δείχνει

				var p *int
	Ο τύπος *T (αστερίσκος Τ) είναι δείκτης σε τιμή της variable Τ. Η μηδενική τιμή του είναι η nil.

	Όταν π.χ. γράφουμε *xPtr = 0 εννοούμε “βάλε τον int 0 στη θέση μνήμης που δείχνει ο xPtr”.
	Αν αντίθετα γράψουμε xPtr = 0 θα πάρουμε ένα λάθος απ το μεταγλωττιστή επειδή
	xPtr δεν είναι int, είναι *int, που μπορεί να μας δώσει μόνο ένα άλλο *int.

	Επίσης χρησιμοποιούμε τον τελεστή & για να βρούμε τη διεύθυνση μιας variable.
	Π.χ η &x επιστρέφει *int (pointer to an int) επειδή x είναι int.
	Αυτό είναι που μας επιτρέπει να μετατρέψουμε την αρχική variable.

	Συνοψίζοντας, τα δύο σύμβολα * και & χρησιμοποιούνται:

	& <-- Δείξε προς την διεύθυνση μνήμης μιας variable π.χ. dieuthinsi = &dedomena
	* <-- Διάβασε Από / Διαμέσου της διεύθυνσης μνήμης μιας variable *dieuthinsi

	Έστω:

		i, j := 42, 2701
		p = &i  // Το & εδώ δημιουργεί έναν δείκτη στον τελεστή του.

		fmt.Println(*p) // διαβάζω την i μέσω της διεύθυνσης μνήμης του δείκτη p
		*p = 21         // θέτω την i μέσω του δείκτη p
		Ο τελεστής * υποδηλώνει την υποκείμενη τιμή του δείκτη.	Αυτό είναι γνωστό
		ως "dereferencing" ή "indirecting".

	Σε αντίθεση με τη C, η Go δεν έχει αριθμητικό pointer.

		p = &j         // δείκτης στο j
		*p = *p / 37   // διαίρεσε το j μέσω του δείκτη
		fmt.Println(j) // δες την νέα τιμή του j

*/
/*

 */
func dontChangeXVal(x int) {
	// Δεν έχει επίδραση στην τιμή του x στην main()
	x = 2
}

// * δηλώνει ότι στέλνουμε μια αναφορά στην τιμή
func nowChangeXVal(x *int) {
	// Αλλάξτε την τιμή στη διεύθυνση μνήμης που αναφέρεται από το δείκτη
	// * μας δίνει πρόσβαση στην τιμή που αναφέρεται ο δείκτης
	*x = 2 // Αποθηκεύστε 2 στη διεύθυνση μνήμης που αναφέρεται το x
}

func nowChangeYVal(yPtr *int) {
	*yPtr = 100
}

func changeCerebrux(site *string) string {
	/* Στην Go, οι τιμές επιστροφής μπορούν να ονοματίζονται ή όχι
	 Με άλλα λόγια θα μπορουσε να γραφτεί :
	 func changeCerebrux(site *string) epistrofi string {

		}
	*/

	// Αυτός ο * αστερίσκος στο *site λέει στην Go ότι το site εδώ είναι
	// ένας δείκτης σε μια string που θα δοθεί όταν κληθεί η func δηλαδή
	// στο (site *string)
	*site = "https://cerebrux.net"
	/*
		Θα παρατηρήσετε εδώ ότι κατά την εκχώρηση της νέας τιμής
		στο function μας εδώ, απλά χρησιμοποιούμε τον τελεστή "="
		και όχι το ":=" Αυτό συμβαίνει επειδή δεν δηλώνουμε
		μια νέα μεταβλητή εδώ, απλώς εκχωρούμε μια νέα τιμή σε μια
		υπάρχουσα μεταβλητή που θα μας δοθεί όταν θα κληθεί η function
		πάνω σε αυτή την υπάρχουσα μεταβλητή.
	*/
	fmt.Println("Αλλάζω το site σε", *site)

	return *site
}

func main() {
	// Περνάμε την τιμή μιας variable στη function
	x := 0
	dontChangeXVal(x) // Δεν θα αλλάξει τίποτα
	fmt.Println("Το dontChangeXVal δεν θα αλλάξει τιμή στο x σε 2 αφού είναι", x)

	// Αν περάσουμε μια reference στη variable μπορούμε
	// να αλλάξουμε την τιμή σε μια function

	nowChangeXVal(&x)
	// Θυμηθείτε, πρόκειται να φτιαχτεί ένα αντίγραφο της μεταβλητής
	// μας το οποίο αντίγραφο θα μεταβιβάσετε στη συνάρτηση,
	// οπότε δεν πρόκειται να περάσει η ίδια η μεταβλητή.

	fmt.Println("Το nowChangeXVal θα αλλάξει τιμή στο x σε", x)

	// Πάρτε τη διεύθυνση του x στην οποία δείχνει, με το &
	fmt.Println("Διεύθυνση μνήμης του x είναι", &x) // pointer στην διεύθυνση του x

	// Μπορούμε επίσης να δημιουργήσουμε ένα δείκτη με την new
	yPtr := new(int)
	nowChangeYVal(yPtr)
	fmt.Println("Το nowChangeΥVal θα αλλάξει τιμή στο y σε", *yPtr)

	site := "www.cerebrux.net"
	fmt.Println("Το site είναι", site)

	changeCerebrux(&site) // pointer στο site
	fmt.Println("Το site τώρα είναι", site)
}
