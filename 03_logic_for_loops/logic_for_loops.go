/*
Τι θα μάθουμε:
- Θα δούμε πως δηλώνουμε λογικές συνθήκες,
όπως "αληθείς", "ψευδής", "και", "ή", "είναι", "δεν είναι" κ.α.
- Πως φτιάχνουμε επαναλαμβανόμενες λειτουργίες με βρόγχους for
*/

package main

import (
	"fmt"
	"time"
)

func main() {

	// Λογικοί τελεστές χρησιμοποιούνται για να ελέγξουμε αν μια κατάσταση
	// είναι αληθής (true) ή ψευδής (false)
	// Τα αποτελέσματα χρήσης των τελεστών παριστάνονται παρακάτω:
	fmt.Println(" === Λογικοί τελεστές ===")
	fmt.Println("true && false =", true && false) // && το οποίο σημαίνει "και"
	fmt.Println("true || false =", true || false) // || το οποίο σημαίνει "ή"
	fmt.Println("!true =", !true)                 // ! το οποίο σημαίνει "δεν είναι"
	/*
		Η προτεραιότητα υπολογισμού των τελεστών ορίζεται
		απο πάνω (υψηλή) προς τα κάτω (χαμηλή) ως εξής:
			()
			! + -
			* / %
			+ -
			< <= > >=
			== !=
			&&
			||
	*/

	/*
		Η Go έχει μόνο μία δομή (construct) βρόχου, την "for" loop και δεν
		διαθέτει "while" loop. Μπορεί να ακούγεται λίγο παραπλανητικό αλλά
		αυτό που θα πρέπει να καταλάβετε είναι ότι η Go έχει μόνο μία
		εντολή (μία λέξη -κλειδί) που χρησιμοποιείται για την "επανάληψη"
		μιας διεργασίας.

		Μην σας προβληματίζει αυτό διότι στην Go, η for είναι αρκετά ευέλικτη,
		οπότε μπορούμε να το χρησιμοποιήσουμε σε infinite loop βρόχους,
		μπορούμε να το χρησιμοποιήσουμε σε βρόχο λογικής όπως όταν μια
		έκφραση Boole (λογική συνθήκη) αποτιμάται ως αληθής, μπορούμε
		να το χρησιμοποιήσουμε σε βρόχο που μοιάζει με "while" και
		μπορούμε να το χρησιμοποιήσουμε για να εξετάσουμε μια λίστα τιμών,
		όπως έναν πίνακα ή μια slice ή map (θα τα δούμε σε επόμενο μάθημα).

		Περιλαμβάνει δύο μορφές.

		Η βασική μορφή του βρόχου έχει τρία συστατικά χωρισμένα με ερωτηματικά:

		1) την init statement (αρχική κατάσταση): εκτελείται πριν
		από την πρώτη επανάληψη.
		2) η condition expression (συνθήκη): αξιολογείται πριν από κάθε επανάληψη
		3) η post statement(αποτέλεσμα): εκτελείται στο τέλος κάθε επανάληψης

		Σημείωση: Σε αντίθεση με άλλες γλώσσες, όπως C, Java ή JavaScript,
		δεν υπάρχουν παρενθέσεις που να περιβάλλουν τα τρία στοιχεία της δήλωσης for
		και οι αγκύλες {} απαιτούνται πάντα.

		Η init statement είναι συχνά μια σύντομη δήλωση μεταβλητής και οι μεταβλητές
		που δηλώνονται εκεί είναι ορατές μόνο στο πεδίο της δήλωσης for.
		Ο βρόχος θα σταματήσει την επανάληψη όταν η κατάσταση boolean εκτιμάται ως ψευδής.
		Με άλλα λόγια όσο η συνθήκη που έχουμε δώσει είναι αληθείς,
		το for θα επαναλαμβάνει την διεργασία του.

		Διαδικασίες ελέγχου μιας σχέσης μεταβλητών περιλαμβάνουν :
		-  == (είναι)
		-  != (δεν είναι)
		-  < (μικρότερο απο)
		-  > (μεγαλύτερο από)
		-  <=(μικρότερο ή ίσο με)
		-  >=(μεγαλύτερο ή ίσο με)
	*/
	fmt.Println(" \n === For Loop ===")
	fmt.Println(" \n === απο 1 έως 10 ===")

	i := 1
	// Εδώ βλέπουμε την απλή μορφή με μία συνθήκη που μοιάζει με (while i <= 10)
	for i <= 10 { // Η συνθήκη μας εδώ είναι:
		//  "όσο το i είναι μικρότερο ή ίσο με το 10"

		/* Προσοχή: αν γράψουμε την for χωρίς συνθήκες:

		for {
		}

		τότε θα έχουμε φτιάξει έναν βρόγχο που θα εκτελείται
		στο άπειρο διότι η Go θεωρεί οτι εφόσον έχουμε κενή
		συνθήκη, έχουμε μια bool συνθήκη (αληθής για πάντα):

		*/
		fmt.Println(i) // Ζητάμε να τυπώσει την νέα κατάσταση του i

		i++ // όσο το i
		// είναι μικρότερο ή ίσο με το 10, θα προσθέτουμε 1 στο i.
		// δηλαδή i = i + 1 το οποίο είναι συντομογραφία του i++
	}

	fmt.Println(" \n === For Loop ===")
	fmt.Println(" \n === απο 1 έως 10 ===")
	// Αντίθετα, παρακάτω βλέπουμε τη βασική μορφή της for
	// Ας φτιάξουμε ένα ψεύτικο πρόγραμμα αυτοκαταστροφής

	for j := 10; j >= 0; j-- {
		// init statement (αρχική κατάσταση) όπου το j είναι 0
		// condition expression (συνθήκη), όπου λέμε οτι όσο το j είναι μικρότερο του 5
		// post statement(αποτέλεσμα),τότε αυξάνουμε το j κατα μια μονάδα
		fmt.Println(" \n αυτοκαταστροφή σε:")
		fmt.Println(j)

		pafsi := time.Second // ορίζουμε μια μεταβλητή "pafsi" και του δίνουμε τιμή δευτερολέπτου
		time.Sleep(pafsi)    // του λέμε να περιμένει (time.Sleep) με βάση την τιμή που έχει η "pafsi"
	}

}
